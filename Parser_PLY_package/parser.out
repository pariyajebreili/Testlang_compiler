Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    NUMBER
    COMMENT
    STR
    PLUS
    TIMES
    DIVIDE
    MOD
    MINUS
    LPAREN
    RPAREN
    LBRACE
    RBRACE
    LSQUAREBR
    RSQUAREBR
    COLON
    COMMA
    SEMI_COLON
    LESS_THAN
    LESS_EQUAL
    GREATER_THAN
    GREATER_EQUAL
    EQ
    NOT_EQ
    PARITY
    NOT
    VOID
    FOR
    IF
    ELSE
    RETURN
    WHILE
    PRINT
    TO
    IN
    NUM
    INT
    DEF
    VAR
    AND
    OR
    TRUE
    FALSE
    VECTOR
    TYPE
    IDEN

Grammar

Rule 0     S' -> prog
Rule 1     prog -> func
Rule 2     prog -> func prog

Terminals, with rules where they appear

AND                  : 
COLON                : 
COMMA                : 
COMMENT              : 
DEF                  : 
DIVIDE               : 
ELSE                 : 
EQ                   : 
FALSE                : 
FOR                  : 
GREATER_EQUAL        : 
GREATER_THAN         : 
IDEN                 : 
IF                   : 
IN                   : 
INT                  : 
LBRACE               : 
LESS_EQUAL           : 
LESS_THAN            : 
LPAREN               : 
LSQUAREBR            : 
MINUS                : 
MOD                  : 
NOT                  : 
NOT_EQ               : 
NUM                  : 
NUMBER               : 
OR                   : 
PARITY               : 
PLUS                 : 
PRINT                : 
RBRACE               : 
RETURN               : 
RPAREN               : 
RSQUAREBR            : 
SEMI_COLON           : 
STR                  : 
TIMES                : 
TO                   : 
TRUE                 : 
TYPE                 : 
VAR                  : 
VECTOR               : 
VOID                 : 
WHILE                : 
error                : 
func                 : 1 2

Nonterminals, with rules where they appear

prog                 : 2 0

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . func
    (2) prog -> . func prog

    func            shift and go to state 2

    prog                           shift and go to state 1

state 1

    (0) S' -> prog .



state 2

    (1) prog -> func .
    (2) prog -> func . prog
    (1) prog -> . func
    (2) prog -> . func prog

    $end            reduce using rule 1 (prog -> func .)
    func            shift and go to state 2

    prog                           shift and go to state 3

state 3

    (2) prog -> func prog .

    $end            reduce using rule 2 (prog -> func prog .)

